= Pegasus RISC-V Functional Model
Kathlene Magnus <kathlene.hurt@gmail.com>
:reproducible:
:listing-caption: Listing
:source-highlighter: rouge
:toc:
:title-page: Pegasus RISC-V Functional Model

== Introduction

Pegasus is an open-source RISC-V functional model built using the Sparta modeling framework.

== Actions, Action Groups and Action Exceptions

The Pegasus functional model is driven by executing Action Groups which contain a series of related Actions. An Action is a
functor that represents an independent portion of work that is executed by Pegasus, like decoding an opcode or writing to an
instruction log. Breaking up the Pegasus engine into Actions allows the model to modularly modify itself and to be run more
efficiently.

[source,c++]
----
PegasusState* state = getPegasusStatePtr();
ActionGroup* action_group = getFirstActionGroupPtr();
while (action_group)
{
    action_group = action_group->execute(state);
}
// Nothing else to do, end of simulation
----

An Action Group contains a vector of Actions and a pointer to the next Action Group to be executed. An Action Group is
executed by iterating over its vector of Actions. Once all of the Actions have been executed, the pointer to the next
Action Group is returned. Each Action is responsible for incrementing the iterator used to loop over the vector of Actions.
This allows Actions to be executed multiple times in a row by returning the Action iterator without incrementing it first.
This feature is used to handle misaligned address translation, multiple translation request and vector instructions which
updates multiple destination registers.

[source,c++]
----
std::vector<Actions> actions = getActionVector();
PegasusState* state = getPegasusStatePtr();
Action::ItrType action_it = actions.begin();
const Action::ItrType end_it = actions.end();
while (action_it != end_it)
{
    action_it = action_it->execute(state, action_it);
}
----

There are some scenarios where Pegasus needs to deviate from its standard execution path. While an Action Group is being
executed, an Action can throw an Action Exception. When an Action Exception is thrown, the Action Group will break out
of the loop executing its vector of Actions and return the Action Exception's Action Group. This feature supports the
handling of exceptions that can occur during instruction execution like illegal instruction exceptions, page faults, and
system calls.

[source,c++]
----
std::vector<Actions> actions = getActionVector();
PegasusState* state = getPegasusStatePtr();
Action::ItrType action_it = actions.begin();
const Action::ItrType end_it = actions_.end();
while (action_it != end_it)
{
    try
    {
        action_it = action_it->execute(state, action_it);
    }
    catch (ActionException & action_excp)
    {
        return action_excp.getActionGroup();
    }
}
----

When an Action is executed, it will determine which Action will be executedi next. In most cases, the Action iterator will
be incremented and returned to execute the next Action in the Action Group, or finish the execution of the current Action
Group. To repeat the current Action, the Action will return the Action iterator without incrementing it. To interrupt the
execution of the current Action Group and begin the execution of a new Action Group, the Action will throw an Action
Exception.

[source,c++]
----
Action::ItrType example_action(PegasusState* state, Action::ItrType action_it)
{
    if (exception)
    {
        throw PegasusException(exception_action_group);
    }
    else if (repeat)
    {
        return action_it;
    }
    else
    {
        return ++action_it;
    }
}
----

== Pegasus Core

Pegasus's core engine is comprised of 7 main Action Groups. An 8th Action Group is generated by the
Execute Action Group to handle the execution of the current instruction.

[options="header"]
|===========================================================================================================================
| Action Group            | Class       | Function
| Fetch                   | Fetch       | Requests address translation for the current PC
| Instruction Translation | Translation | Translates virtual addresses of instructions
| Decode                  | Fetch       | Reads opcodes from memory and decodes them using Mavis
| Execute                 | Execute     | Assembles the current instruction's Action Group
| Data Translation        | Translate   | Translates virtual addresses of data for instructions that access memory
| Exception               | Exception   | Handles exceptions
| Finish                  | Pegasus State | Updates the program and simulator state after an instruction is finished executing
|===========================================================================================================================

image::pegasus_core_action_groups.png[]

