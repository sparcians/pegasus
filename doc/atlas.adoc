= Atlas RISC-V Functional Model
Kathlene Magnus <kathlene.hurt@gmail.com>
:reproducible:
:listing-caption: Listing
:source-highlighter: rouge
:toc:
:title-page: Atlas RISC-V Functional Model

== Introduction

Atlas is an open-source RISC-V functional model built using the Sparta modeling framework.

== Actions, Action Groups and Action Exceptions

The Atlas functional model is driven by executing Action Groups which contain a series of related Actions. An Action is a
functor that represents an independent portion of work that is executed by Atlas, like decoding an opcode or writing to an
instruction log. Breaking up the Atlas engine into Actions allows the model to modularly modify itself and to be run more
efficiently.

[source,c++]
----
AtlasState* state = getAtlasStatePtr();
ActionGroup* action_group = getFirstActionGroupPtr();
while (action_group)
{
    action_group = action_group->execute(state);
}
// Nothing else to do, end of simulation
----

An Action Group contains a vector of Actions and a pointer to the next Action Group to be executed. An Action Group is
executed by iterating over its vector of Actions. Once all of the Actions have been executed, the pointer to the next
Action Group is returned. Each Action is responsible for incrementing the iterator used to loop over the vector of Actions.
This allows Actions to be executed multiple times in a row by returning the Action iterator without incrementing it first.
This feature is used to handle misaligned address translation, multiple translation request and vector instructions which
updates multiple destination registers.

[source,c++]
----
std::vector<Actions> actions = getActionVector();
AtlasState* state = getAtlasStatePtr();
Action::ItrType action_it = actions.begin();
const Action::ItrType end_it = actions.end();
while (action_it != end_it)
{
    action_it = action_it->execute(state, action_it);
}
---

TODO: Action Exceptions

[source,c++]
----
std::vector<Actions> actions = getActionVector();
AtlasState* state = getAtlasStatePtr();
Action::ItrType action_it = actions.begin();
const Action::ItrType end_it = actions_.end();
while (action_it != end_it)
{
    try
    {
        action_it = action_it->execute(state, action_it);
    }
    catch (ActionException & action_excp)
    {
        return action_excp.getActionGroup();
    }
}
----

TODO: Action functions

Action::ItrType example_action(AtlasState* state, Action::ItrType action_it)
{
    if (exception)
    {
        throw AtlasException(exception_action_group);
    }
    else if (repeat)
    {
        return action_it;
    }
    else
    {
        return ++action_it;
    }
}
---

== Atlas Core

Atlas's core engine is comprised of 7 main Action Groups. An 8th Action Group is generated by the
Execute Action Group to handle the execution of the current instruction.

[options="header"]
|===========================================================================================================================
| Action Group            | Class       | Function
| Fetch                   | Fetch       | Requests address translation for the current PC
| Instruction Translation | Translation | Translates virtual addresses of instructions
| Decode                  | Fetch       | Reads opcodes from memory and decodes them using Mavis
| Execute                 | Execute     | Assembles the current instruction's Action Group
| Data Translation        | Translate   | Translates virtual addresses of data for instructions that access memory
| Exception               | Exception   | Handles exceptions
| Finish                  | Atlas State | Updates the program and simulator state after an instruction is finished executing
|===========================================================================================================================

image::atlas_core_action_groups.png[]

